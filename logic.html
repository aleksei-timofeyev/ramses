<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Overview &mdash; ramses 28.0.0-rc1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Minimal logic example" href="examples/logic/00_minimal.html" />
    <link rel="prev" title="Minimal example" href="examples/core/00_minimal.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Quickstart</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme_ref.html">RAMSES</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Building</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="build.html">Cloning</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html#build-requirements">Build requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html#build-options">Build options</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html#project-version">Project version</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html#building-on-windows">Building on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html#building-on-linux-natively">Building on Linux natively</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Core API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="core.html">Ramses Core overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="core.html#advanced-concepts">Advanced concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="core.html#list-of-all-examples">List of all examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Logic API</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#object-types-and-their-relationships">Object types and their relationships</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-flow">Data flow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#logic-node-creation">Logic node creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="#object-lifecycle">Object lifecycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="#creating-links-between-nodes">Creating links between nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="#linking-logic-nodes-to-ramses-scenes">Linking logic nodes to Ramses scenes</a></li>
<li class="toctree-l1"><a class="reference internal" href="#dynamic-sorting-of-content">Dynamic sorting of content</a></li>
<li class="toctree-l1"><a class="reference internal" href="#animations">Animations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#data-arrays">Data Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#animation-nodes">Animation Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#timer-node">Timer Node</a></li>
<li class="toctree-l2"><a class="reference internal" href="#static-vs-dynamic-animation-data">Static vs. dynamic animation data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#error-handling">Error handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="#iterating-over-object-collections">Iterating over object collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="#saving-loading-from-file">Saving/Loading from file</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#object-lifecycle-when-saving-and-loading-to-files">Object lifecycle when saving and loading to files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-compatibility">File compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-compatibility-prior-version-1-1-and-feature-levels">File compatibility (prior version 1.1 and feature levels)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#saving-and-loading-together-with-a-ramses-scene">Saving and loading together with a Ramses scene</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-memory-buffer-instead-of-file">Using memory buffer instead of file</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#logging">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="#security-and-memory-safety">Security and memory safety</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#additional-memory-safety-measures">Additional memory safety measures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#additional-security-considerations">Additional security considerations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sanitizing-of-files-and-buffers">Sanitizing of files and buffers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#performance">Performance</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#profiling-logic-update-cycles">Profiling logic update cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimizing-lua-code">Optimizing Lua code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#benchmarks">Benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimizing-file-size">Optimizing file size</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#list-of-all-logic-examples">List of all logic examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/00_minimal.html">Minimal logic example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/01a_primitive_properties.html">Example with primitive properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/01b_struct_properties.html">Example with structured properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/01c_array_properties.html">Example with indexed (vector, array) properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/02_errors_compile_time.html">Handling compilation errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/03_errors_runtime.html">Handling runtime errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/04_ramses_scene.html">Example with Ramses</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/05_serialization.html">Save/load from file example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/07_links.html">Links example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/08a_static_animation.html">Animation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/08b_dynamic_animation.html">Dynamic animation (animateTo) example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/09_modules.html">Modules example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/10_globals.html">Globals example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/11_interfaces.html">Interfaces example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/12_anchor_point.html">Anchor points example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/13_render_order.html">Render order example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/14_skinbinding.html">SkinBinding example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/logic/15_meshnodebinding.html">MeshNodeBinding example</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Lua Syntax</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#basics-of-lua">Basics of Lua</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#declaring-an-interface-and-a-run-function">Declaring an interface() and a run() function</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#global-variables-and-the-init-function">Global variables and the init() function</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#custom-functions">Custom functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#environments-and-isolation">Environments and isolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#indexing-inside-lua">Indexing inside Lua</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#errors-in-scripts">Errors in scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#using-lua-modules">Using Lua modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="lua_syntax.html#additional-lua-syntax-specifics">Additional Lua syntax specifics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Viewer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="viewer.html">ramses-logic-viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="viewer.html#lua-configuration-api">Lua configuration API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Class Index</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="classes/index.html">Class Index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ChangeLog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog_ref.html">Ramses Changelog</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="dev.html">Understand RAMSES Logic architecture and design</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#developer-guidelines">Developer guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#pull-requests">Pull requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#commit-guidelines">Commit guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#review">Review</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#code-style">Code style</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#continuous-integration">Continuous integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html#branching">Branching</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ramses</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Overview</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h1>
<p>This page provides an overview of the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> C++ API, primary object types, structure and interaction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prefer learning by example? Jump straight to the <a class="reference internal" href="core.html#list-of-all-examples"><span class="std std-ref">examples</span></a>!
Looking for a specific class or method? Check the <a class="reference internal" href="classes/index.html#class-index"><span class="std std-ref">class index</span></a></p>
</div>
<section id="object-types-and-their-relationships">
<h2>Object types and their relationships<a class="headerlink" href="#object-types-and-their-relationships" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> consists of a network of logical <code class="docutils literal notranslate"><span class="pre">nodes</span></code> with a set of inputs and outputs and
links between them to send data from one node to another.</p>
<p>The following graph shows an example of such network:</p>
<img alt="_images/overview.svg" src="_images/overview.svg" /><p>There are different types of logic nodes (Interfaces, Lua scripts, Animations, Bindings) which have different
execution logic, but all share the same mechanism to link data between the nodes. Each node has a set of inputs
and outputs which can be linked together to transfer data from one (node output) to another (node input).</p>
<p>The logic nodes have inputs and outputs which let them interact with other entities
(can be other logic nodes, or ramses objects, or application code/data). Logic nodes
can be linked together using directional links, where the output of one node provides its data to
the input of another node (<a class="reference internal" href="#creating-links-between-nodes"><span class="std std-ref">more info on links</span></a>).
Logical nodes can’t interact with Ramses objects directly. Instead, they
can link to <code class="docutils literal notranslate"><span class="pre">Bindings</span></code> which are designed to “bind” <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> objects and modify
their properties’ values (node visibility, transformation values, material properties… etc.)
(<a class="reference internal" href="#linking-logic-nodes-to-ramses-scenes"><span class="std std-ref">more info on bindings</span></a>).</p>
<p>The greyed-out slots in the image above represent input properties which are neither linked nor
have a statically configured value. In bindings, this denotes that the corresponding <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> property
is not being updated by the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> (see also <a class="reference internal" href="#data-flow"><span class="std std-ref">the section on data flow</span></a>). In other nodes, these
properties will receive a default value at runtime (<code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0f</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code> etc.) unless explicitly set by the application
logic. Bindings’ input values are initialized with the values of the bound <cite>Ramses</cite> object, for all bindings except
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesAppearanceBinding</span></code>.</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">Interface</span> <span class="pre">nodes</span></code> have no execution logic, only inputs (and implicit outputs which are identical to the inputs).
Interfaces are supposed to be the bridge between application code/data and the Ramses/Logic asset.
Interface input values are supposed to be explicitly set at runtime, or statically linked to other outputs.
Ideally, the logic node network with interfaces should be designed so that once all the interfaces’ inputs are set, the
whole underlying network of nodes is fully defined, i.e. all inputs of all nodes are linked.</p>
</section>
<section id="data-flow">
<h2>Data flow<a class="headerlink" href="#data-flow" title="Permalink to this heading"></a></h2>
<p>The cornerstone of the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> is the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine6updateEv" title="ramses::LogicEngine::update"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::update()</span></code></a> method which
“executes” the network of logic nodes and updates the values of the <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene bound to them. The nodes
are executed based on a topological graph sort, where the traversal direction is given by the link
pairs (A, B) where A is an output and B is an input property in the logic graph
(as shown <a class="reference internal" href="#object-types-and-their-relationships"><span class="std std-ref">here</span></a>).</p>
<p>The update logic of each node depends on its type. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LuaScript</span></code> nodes execute their <code class="docutils literal notranslate"><span class="pre">run()</span></code> function
and modify some or all of their outputs based on the logic defined in <code class="docutils literal notranslate"><span class="pre">run()</span></code>.
Nodes which derive from <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesBinding</span></code> pass the values of their
input properties to the bound Ramses object. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LuaInterface</span></code> nodes
pass the values of their inputs to other nodes connected to the interface’s outputs.</p>
<p>Logic nodes are not executed on every <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine6updateEv" title="ramses::LogicEngine::update"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::update()</span></code></a> iteration in order to save performance.
However, it’s guaranteed that:</p>
<ul class="simple">
<li><p>logic nodes which were just created will be executed on next update</p></li>
<li><p>logic nodes whose inputs received a new value (either from calling <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::Property::set()</span></code> or from a link)
will be executed on next update</p></li>
<li><p>binding properties which received a value (regardless of their current value or from the value stored in Ramses) will
overwrite the value in Ramses on next update. This works both for direct <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::Property::set()</span></code> calls and for values
received over links</p></li>
<li><p>TimerNodes will be executed always, regardless if their inputs were set</p></li>
</ul>
<p>Additionally, bindings’ properties are applied selectively - e.g. setting the <code class="docutils literal notranslate"><span class="pre">scaling</span></code> property of a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesNodeBinding</span></code>
will result in a call to <code class="docutils literal notranslate"><span class="pre">ramses::Node::setScaling()</span></code>, but will not cause setting any other <code class="docutils literal notranslate"><span class="pre">ramses::Node</span></code> properties.
This can be useful if you want to have your own logic e.g.
to control the visibility of all <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> nodes, and only use a <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> to control transformation properties. In that case
you should never set the <code class="docutils literal notranslate"><span class="pre">visibility</span></code> property of a Binding object, instead set the visibility directly on the bound <code class="docutils literal notranslate"><span class="pre">ramses::Node</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We strongly discourage setting values to <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> objects and to <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> bindings in the same update cycle
for the same property to avoid unexpected behavior. At any given time, use one <em>or</em> the other, not both mechanisms to set values!</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> can be also serialized and deserialized into binary files for fast loading.
The above data flow rules still apply as if all the scripts and binding objects were just created. The first call to
<a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine6updateEv" title="ramses::LogicEngine::update"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::update()</span></code></a> after loading from file will execute all scripts. Binding values will only be passed further to <code class="docutils literal notranslate"><span class="pre">Ramses</span></code>
if their values were modified, e.g. by a link which produced a different value than before saving, or if the application
called <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::Property::set()</span></code> explicitly on any of the bindings’ input properties. For more details on saving and loading,
see the <a class="reference internal" href="#saving-loading-from-file"><span class="std std-ref">section further down</span></a>.</p>
</section>
</section>
<section id="logic-node-creation">
<h1>Logic node creation<a class="headerlink" href="#logic-node-creation" title="Permalink to this heading"></a></h1>
<p>The entry point to <code class="docutils literal notranslate"><span class="pre">RAMSES</span> <span class="pre">logic</span></code> is a factory-style class <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> which can
create instances of all other types of objects supported by <code class="docutils literal notranslate"><span class="pre">RAMSES</span> <span class="pre">Logic</span></code>:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LuaScript</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesNodeBinding</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesAppearanceBinding</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesCameraBinding</span></code></p></li>
</ul>
<p>See the full list over at the <a class="reference internal" href="classes/index.html#class-index"><span class="std std-ref">class index</span></a>.</p>
<p>You can create multiple instances of <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a>, but each copy owns the objects it
created, and must be used to destroy them, as befits a factory class.</p>
<p>You can create scripts using the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ramses-logic/LogicEngine.h&quot;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ramses</span><span class="o">::</span><span class="nn">logic</span><span class="p">;</span>
<span class="linenos"> 4</span>
<span class="hll"><span class="linenos"> 5</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span>
</span><span class="hll"><span class="linenos"> 6</span><span class="s">    function interface(IN, OUT)</span>
</span><span class="hll"><span class="linenos"> 7</span><span class="s">        IN.gear = Type:Int32()</span>
</span><span class="hll"><span class="linenos"> 8</span><span class="s">        OUT.speed = Type:Float()</span>
</span><span class="hll"><span class="linenos"> 9</span><span class="s">    end</span>
</span><span class="hll"><span class="linenos">10</span>
</span><span class="hll"><span class="linenos">11</span><span class="s">    function run(IN, OUT)</span>
</span><span class="hll"><span class="linenos">12</span><span class="s">        OUT.speed = IN.gear * 15</span>
</span><span class="hll"><span class="linenos">13</span><span class="s">    end</span>
</span><span class="hll"><span class="linenos">14</span><span class="dl">)</span><span class="s">&quot;</span>
</span><span class="linenos">15</span>
<span class="hll"><span class="linenos">16</span><span class="n">LogicEngine</span><span class="w"> </span><span class="n">engine</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">17</span><span class="n">LuaScript</span><span class="o">*</span><span class="w"> </span><span class="n">script</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">engine</span><span class="p">.</span><span class="n">createLuaScript</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;simple script&quot;</span><span class="p">);</span>
</span><span class="linenos">18</span><span class="n">script</span><span class="o">-&gt;</span><span class="n">getInputs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getChild</span><span class="p">(</span><span class="s">&quot;gear&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="n">script</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
<span class="linenos">21</span><span class="kt">float</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">script</span><span class="o">-&gt;</span><span class="n">getOutputs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getChild</span><span class="p">(</span><span class="s">&quot;speed&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">22</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;OUT.speed == &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span>
</pre></div>
</div>
<p>For details regarding the <code class="docutils literal notranslate"><span class="pre">Lua</span></code> syntax and its specifics, check the <a class="reference internal" href="lua_syntax.html#basics-of-lua"><span class="std std-ref">dedicated section on Lua</span></a>.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code> (the base class of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LuaScript</span></code>) provides an interface to access the inputs and outputs declared by the <code class="docutils literal notranslate"><span class="pre">interface()</span></code>
function - see <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicNode::getInputs()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicNode::getOutputs()</span></code>.</p>
<p>You can <a class="reference internal" href="#creating-links-between-nodes"><span class="std std-ref">link nodes</span></a> to form a more sophisticated logic execution graph.</p>
<p>You can <a class="reference internal" href="#linking-logic-nodes-to-ramses-scenes"><span class="std std-ref">bind to Ramses objects</span></a> to control a 3D <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene.</p>
<p>Finally, the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class and all its content can be also saved/loaded from a file. Refer to
<a class="reference internal" href="#saving-loading-from-file"><span class="std std-ref">the section on saving/loading from files for more details</span></a>.</p>
</section>
<section id="object-lifecycle">
<h1>Object lifecycle<a class="headerlink" href="#object-lifecycle" title="Permalink to this heading"></a></h1>
<p>All objects besides the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> instance follow a strict factory pattern.
An object <code class="docutils literal notranslate"><span class="pre">X</span></code> is created by a method of the shape <code class="docutils literal notranslate"><span class="pre">X*</span> <span class="pre">LogicEngine::createX(...)</span></code>. The pointer
returned shall not be freed or deleted, instead objects must be destroyed by calling <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine7destroyER11LogicObject" title="ramses::LogicEngine::destroy"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::destroy()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This may seem strange for a library which is based on <code class="docutils literal notranslate"><span class="pre">C++17</span></code>, but there are good reasons
for this design choice. Smart pointers don’t work well together with Windows DLL’s, specifically
when combining different CRTs. In order to provide a stable API on Windows
we chose to use raw pointers and hide object creation/deletion behind a pimpl/factory pattern.</p>
</div>
<p>The <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> doesn’t create or destroy objects on its own - all data is
explicitly created by calling <code class="docutils literal notranslate"><span class="pre">create</span></code> and <code class="docutils literal notranslate"><span class="pre">destroy</span></code> methods. There are two special cases worth mentioning:</p>
<ul class="simple">
<li><p>if <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> is destroyed, all objects are destroyed as well and theirs pointers invalidated</p></li>
<li><p><a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine12loadFromFileENSt11string_viewEPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromFile()</span></code></a> destroys all objects previously created before the new content is loaded from the file</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Loading data from files will invalidate all previous pointers to objects in
the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a>. To avoid that, we recommend generally avoiding using
a logicengine instance which already has content to load from files, and instead always
create a fresh instance.</p>
</div>
</section>
<section id="creating-links-between-nodes">
<h1>Creating links between nodes<a class="headerlink" href="#creating-links-between-nodes" title="Permalink to this heading"></a></h1>
<p>One of the complex problems of 3D graphics development is managing complexity, especially for larger projects.
For that purpose it is useful to split the application logic into multiple logic nodes (usually Lua scripts), so that individual nodes
can remain small and easy to understand. To do that, <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> provides a mechanism to link node
properties - either statically or during runtime, in order to pass data from <code class="docutils literal notranslate"><span class="pre">1</span></code> producer node to <code class="docutils literal notranslate"><span class="pre">N</span></code>
consumer nodes.</p>
<p>Here is a simple example how links are created to link two Lua scripts:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">LogicEngine</span><span class="w"> </span><span class="n">logicEngine</span><span class="p">;</span>
<span class="linenos"> 2</span><span class="n">LuaScript</span><span class="o">*</span><span class="w"> </span><span class="n">sourceScript</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logicEngine</span><span class="p">.</span><span class="n">createLuaScript</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span>
<span class="linenos"> 3</span><span class="s">    function interface(IN, OUT)</span>
<span class="linenos"> 4</span><span class="s">        OUT.source = Type:String()</span>
<span class="linenos"> 5</span><span class="s">    end</span>
<span class="linenos"> 6</span><span class="s">    function run(IN, OUT)</span>
<span class="linenos"> 7</span><span class="s">        OUT.source = &quot;World!&quot;</span>
<span class="linenos"> 8</span><span class="s">    end</span>
<span class="linenos"> 9</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="n">LuaScript</span><span class="o">*</span><span class="w"> </span><span class="n">destinationScript</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logicEngine</span><span class="p">.</span><span class="n">createLuaScript</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span>
<span class="linenos">12</span><span class="s">    function interface(IN)</span>
<span class="linenos">13</span><span class="s">        IN.destination = Type:String()</span>
<span class="linenos">14</span><span class="s">    end</span>
<span class="linenos">15</span><span class="s">    function run()</span>
<span class="linenos">16</span><span class="s">        print(&quot;Hello, &quot; .. IN.destination)</span>
<span class="linenos">17</span><span class="s">    end</span>
<span class="linenos">18</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="n">logicEngine</span><span class="p">.</span><span class="n">link</span><span class="p">(</span>
<span class="linenos">21</span><span class="w">    </span><span class="o">*</span><span class="n">sourceScript</span><span class="o">-&gt;</span><span class="n">getOutputs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getChild</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">),</span>
<span class="linenos">22</span><span class="w">    </span><span class="o">*</span><span class="n">destinationScript</span><span class="o">-&gt;</span><span class="n">getInputs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getChild</span><span class="p">(</span><span class="s">&quot;destination&quot;</span><span class="p">));</span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="c1">// This will print &#39;Hello, World!&#39; to the console</span>
<span class="linenos">25</span><span class="n">logicEngine</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>
</pre></div>
</div>
<p>In this simple example, the ‘sourceScript’ provides string data to the ‘destinationScript’ every time the  <code class="docutils literal notranslate"><span class="pre">LogicEngine::update</span></code>
method is called. The ‘destinationScript’ receives the data in its input property and can process  it further. After
two scripts are linked in this way, the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> will execute them in a order which ensures data consistency, i.e.
scripts which provide data to other scripts’ inputs are executed first. In this example, the ‘sourceScript’ will be executed before
the ‘destionationScript’ because it provides data to it over the link.</p>
<p>Creating links as shown above enforces a so-called ‘directed acyclic graph’, or <code class="docutils literal notranslate"><span class="pre">DAG</span></code>, to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code> inside a given
<a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a>. In order to ensure data consistency, this graph can not have cyclic dependencies, thus following operations
will cause an error:</p>
<ul class="simple">
<li><p>Creating a link from any <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code> to itself</p></li>
<li><p>Creating a link from node A to node B if node B is linked to node A (links have a direction and this creates a two-node loop!)</p></li>
<li><p>Any set of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code> instances whose links form a (directed) circle, e.g. A-&gt;B-&gt;C-&gt;A (this is caught at update time, not at link creation time)</p></li>
</ul>
<p>There is an exception to the ‘no cycles’ rule if using weak links. These allow data propagation in a cycle which would not be
possible with regular links. Weak links should be used only if absolutely necessary and it is essential to fully understand their caveats
and limitations first before using them. See <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine8linkWeakERK8PropertyRK8Property" title="ramses::LogicEngine::linkWeak"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::linkWeak()</span></code></a> for details.</p>
<p>A link can be removed in a similar fashion:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">logicEngine</span><span class="p">.</span><span class="n">unlink</span><span class="p">(</span>
<span class="linenos">2</span><span class="w">    </span><span class="o">*</span><span class="n">sourceScript</span><span class="o">-&gt;</span><span class="n">getOutputs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getChild</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">),</span>
<span class="linenos">3</span><span class="w">    </span><span class="o">*</span><span class="n">destinationScript</span><span class="o">-&gt;</span><span class="n">getInputs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getChild</span><span class="p">(</span><span class="s">&quot;destination&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>For more detailed information on the exact behavior of these methods, refer to the documentation of the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine4linkERK8PropertyRK8Property" title="ramses::LogicEngine::link"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::link()</span></code></a>
and <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine6unlinkERK8PropertyRK8Property" title="ramses::LogicEngine::unlink"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::unlink()</span></code></a> documentation. The <a class="reference external" href="DataFlow">data flow section</a> explains in detail how data is passed throughout the
network of logic nodes when connected by links.</p>
</section>
<section id="linking-logic-nodes-to-ramses-scenes">
<h1>Linking logic nodes to Ramses scenes<a class="headerlink" href="#linking-logic-nodes-to-ramses-scenes" title="Permalink to this heading"></a></h1>
<p>Lua scripts would not make much sense on their own if they can’t interact with <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene objects. The way to
link script output properties to <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene objects is by creating <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesBinding</span></code> instances and linking their inputs to scripts’ outputs.
There are different binding types depending on the type of <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> object - refer to <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesBinding</span></code> for the full list of derived classes.
Bindings can be linked in the exact same way as <a class="reference internal" href="#creating-links-between-nodes"><span class="std std-ref">scripts can</span></a>. In fact, they derive from the
same base class - <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code>. The only
difference is that the bindings have only input properties (the outputs are implicitly defined and statically linked to the Ramses
objects attached to them), whereas scripts have inputs and outputs explicitly defined in the script interface.</p>
<p>One might wonder, why not allow to directly link script outputs to <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> objects?
The reason for that is two-fold:</p>
<ul class="simple">
<li><p>Separation of concerns between pure script logic and <code class="docutils literal notranslate"><span class="pre">Ramses</span></code>-related scene updates</p></li>
<li><p>This allows to handle all inputs and outputs in a generic way using the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code> class’ interface from
which both <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LuaScript</span></code> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesNodeBinding</span></code> derive</p></li>
</ul>
<p>The <a class="reference external" href="DataFlow">section on data flow</a> describes how data is passed throughout the network of logic nodes and when
bound Ramses objects are updated and when not.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Binding input values are initialized with the same values as the <cite>Ramses</cite> objects they “bind”. The only
exception to this are Appearance bindings - extracting all data from Ramses Appearances would incur performance
costs not worth the convenience.</p>
</div>
</section>
<section id="dynamic-sorting-of-content">
<h1>Dynamic sorting of content<a class="headerlink" href="#dynamic-sorting-of-content" title="Permalink to this heading"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> provides a mechanism to dynamically sort select <code class="docutils literal notranslate"><span class="pre">ramses::MeshNode</span></code> and <code class="docutils literal notranslate"><span class="pre">ramses::RenderGroup</span></code>
objects. To do so, you can use the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesRenderGroupBinding</span></code> class. The class works similarly to
other binding classes - it statically binds to Ramses content (configured using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesRenderGroupBindingElements</span></code>)
and allows setting the rendering priority of the bound content by setting input properties of type <code class="docutils literal notranslate"><span class="pre">Int32</span></code> with a name as
configured in <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesRenderGroupBindingElements</span></code>.</p>
</section>
<section id="animations">
<h1>Animations<a class="headerlink" href="#animations" title="Permalink to this heading"></a></h1>
<p>Animations are central to any dynamic real-time scene. It is possible to implement simple animations with <code class="docutils literal notranslate"><span class="pre">Lua</span></code> scripts
or even write your own <code class="docutils literal notranslate"><span class="pre">C++</span></code> wrapper which changes a value over time, linked to a <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> object via <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesBinding</span></code>.
However, such solution would not scale well for more complex animations with preauthored
splines of keyframes and timestamps. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::DataArray</span></code> are designed to provide a good
compromise between performance and a data-centric design which imports animation data from external sources or formats.</p>
<p>The animation support in <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> is provided by the following two classes:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::DataArray</span></code> - contains the animation data (keyframes and time stamps)</p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code> - provides an interface to control and holds the current state of animations</p></li>
</ul>
<p>Consider also using :class`ramses::TimerNode` for easy way to generate and provide timing information to <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code>.</p>
<section id="data-arrays">
<h2>Data Arrays<a class="headerlink" href="#data-arrays" title="Permalink to this heading"></a></h2>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::DataArray</span></code> is a simple data container with immutable data. Various data types and interpolation types are supported (see the
class documentation for details). Data arrays by themselves have no meaning, they must be bundled in animation channels (<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ramses::AnimationChannel</span></code>).
The contents of an animation channel depends on its type. For example, a simple linear animation only needs two data arrays - one for time stamps and
one for key frames. A complex cubic animation channel also needs tangent arrays. It is possible to reuse the same data array in multiple channels - e.g.
if multiple channels use the same time stamps (often the case for multi-channel animations).</p>
</section>
<section id="animation-nodes">
<h2>Animation Nodes<a class="headerlink" href="#animation-nodes" title="Permalink to this heading"></a></h2>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code> holds the state of an animation and provides inputs to control it and outputs to check the
output values or to link them to other scripts or directly to instances of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesBinding</span></code>.
To query input and output properties, use the corresponding methods in the base class <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code>.
Based on how many animation channels were provided when creating the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code>
has an output property of corresponding data type (matching the keyframes data type) for each channel.
The value of these outputs is updated after every <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine6updateEv" title="ramses::LogicEngine::update"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::update()</span></code></a> call and can be directly queried
or it can be linked to any other logic node, e.g. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::RamsesBinding</span></code>.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code> has a simple control interface, the <code class="docutils literal notranslate"><span class="pre">progress</span></code> input is a point in [0,1] normalized range,
which tells the animation node logic to which position on the animation timeline to jump to during next update. The local animation
timeline is simply starting from time zero to the last animation timestamp and <code class="docutils literal notranslate"><span class="pre">progress</span></code> is the normalized form of that.
This gives the application full control over the way how time is applied to the animation, e.g. changing speed, reverse play, rewind,
pause, restart etc., are all possible either from a control Lua script linked to the <code class="docutils literal notranslate"><span class="pre">progress</span></code> or from C++ API.</p>
</section>
<section id="timer-node">
<h2>Timer Node<a class="headerlink" href="#timer-node" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">logic</span></code> provides a tool that can help with dealing with time in your application, a :class`ramses::TimerNode` can be a central node
which provides timing to all animation related logic. Timer node can operate in two modes, either generate time using system clock or forward
application provided time to the logic network. This allows quick and easy switch between stages of the development, e.g. prototyping, testing
or production, where for some use cases auto-generated time is easier to work and some require well specified timing provided by application.
There can also be multiple timer nodes so different time contexts can be specified if needed.</p>
</section>
<section id="static-vs-dynamic-animation-data">
<h2>Static vs. dynamic animation data<a class="headerlink" href="#static-vs-dynamic-animation-data" title="Permalink to this heading"></a></h2>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code> can be used in two different modes, with static data or dynamic data. By default animation node’s animation data
(timestamps, keyframes) cannot be modified after the data is provided when creating an instance of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code>, it is static.
There is however a way to create <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code> which allows modifying the animation data at any point in time, even during animating
- enable <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::AnimationNodeConfig::setExposingOfChannelDataAsProperties()</span></code> when creating the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::AnimationNode</span></code>.
Animation node created this way will have exact same functionality as the static version but in addition exposes some animation data in form
of node properties, namely timestamps and keyframes from all its channels. The animation data properties can be used as any other logic node properties,
they can be set directly or linked to another node.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Animation node with exposed data as properties is limited to a fixed maximum number of keyframes
(see <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::AnimationNodeConfig::setExposingOfChannelDataAsProperties()</span></code> for details) and suffers from a relatively high performance hit
when animating compared to the default ‘static’ animation node. The performance hit scales with the number of keyframes,
keep them as low as possible when using it!</p>
</div>
</section>
</section>
<section id="error-handling">
<h1>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this heading"></a></h1>
<p>Some of the <code class="docutils literal notranslate"><span class="pre">RAMSES</span> <span class="pre">Logic</span></code> classes’ methods can issue errors when used incorrectly or when
a <code class="docutils literal notranslate"><span class="pre">Lua</span></code> script encounters a compile-time or run-time error. Those errors are globally collected
by the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class and can be obtained by calling <a class="reference internal" href="classes/logic.html#_CPPv4NK6ramses11LogicEngine9getErrorsEv" title="ramses::LogicEngine::getErrors"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::getErrors()</span></code></a>.
The error information stored in <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ramses::ErrorData</span></code> contains additional stack trace information for Lua runtime errors,
and a pointer to the originating <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicNode</span></code> which caused the error for errors which occured during <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine6updateEv" title="ramses::LogicEngine::update"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::update()</span></code></a>
and can’t be directly attributed to a specific API call.
Beware that any of the mutable methods of <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> clear the previously generated errors
in the list, so that the list only ever contains the errors since the last method call!</p>
<p>For code samples which demonstrate how compile-time and runtime errors can be gracefully handled,
have a look at the <a class="reference internal" href="core.html#list-of-all-examples"><span class="std std-ref">examples</span></a>.</p>
<p>To intercept and fix potential content problems, you can use <a class="reference internal" href="classes/logic.html#_CPPv4NK6ramses11LogicEngine8validateEv" title="ramses::LogicEngine::validate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::validate()</span></code></a>. This method will
scan the contents of the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> and report pontential issues which are not fatal, but may result in suboptimal
performance, data inconsistency or serialization bugs. It is highly advised to use this method in conjunction with the
<code class="docutils literal notranslate"><span class="pre">Ramses</span></code> validation methods (StatusObject::validate) to prevent issues during runtime.</p>
</section>
<section id="iterating-over-object-collections">
<h1>Iterating over object collections<a class="headerlink" href="#iterating-over-object-collections" title="Permalink to this heading"></a></h1>
<p>Iterating over objects can be useful, for example when <a class="reference internal" href="#saving-loading-from-file"><span class="std std-ref">loading content from files</span></a>
or when applying search or filter algorithms over all objects from a specific type.
The <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class provides iterator-style access to all of its objects:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">LogicEngine</span><span class="w"> </span><span class="n">logicEngine</span><span class="p">;</span>
<span class="linenos">2</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">LuaScript</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allScripts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logicEngine</span><span class="p">.</span><span class="n">scripts</span><span class="p">();</span>
<span class="linenos">3</span>
<span class="linenos">4</span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">script</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">allScripts</span><span class="p">)</span>
<span class="linenos">5</span><span class="p">{</span>
<span class="linenos">6</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Script name: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">script</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">7</span><span class="p">}</span>
</pre></div>
</div>
<p>The <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::Collection</span></code> class and the iterators it returns are STL-compatible, meaning that you can use them with any
other STL algorithms or libraries which adhere to STL principles. The iterators implement <code class="docutils literal notranslate"><span class="pre">forward</span></code> iterator semantics
(<a class="reference external" href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">have a look at C++ docs</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::Iterator</span></code> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::Collection</span></code> classes are not following the <code class="docutils literal notranslate"><span class="pre">pimpl</span></code> pattern as the rest of
the <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> to performance ends. Be careful not to depend on any internals of the classes (mostly the Internally
wrapped STL containers) to avoid compatibility problems when updating the <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> version!</p>
</div>
</section>
<section id="saving-loading-from-file">
<h1>Saving/Loading from file<a class="headerlink" href="#saving-loading-from-file" title="Permalink to this heading"></a></h1>
<p>The <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class and its content can be stored in a file and loaded from file again using the functions
<a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine10saveToFileENSt11string_viewERK14SaveFileConfig" title="ramses::LogicEngine::saveToFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::saveToFile()</span></code></a> and <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine12loadFromFileENSt11string_viewEPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromFile()</span></code></a>. The latter has an optional argument
to provide a <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene which should be used to resolve references to Ramses objects in the Logic Engine file. Read
further for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even though it would be technically possible to combine the storing and loading of Ramses scenes together with the Logic Engine
and its scripts in a single file, we decided to not do this but instead keep the content in separate files and load/save it independently.
This allows to have the same Ramses scene stored multiple times or with different settings, but using the same logic content,
as well as the other way around - having different logic implementations based on the same Ramses scene. It also leaves more freedom
to choose how to store the Ramses scene. This implies that at most a single Ramses scene can be referenced at the time of saving,
having more than one scene will result in error.</p>
</div>
<section id="object-lifecycle-when-saving-and-loading-to-files">
<h2>Object lifecycle when saving and loading to files<a class="headerlink" href="#object-lifecycle-when-saving-and-loading-to-files" title="Permalink to this heading"></a></h2>
<p>After loading,
the current state of the logic engine objects will be completely overwritten by the contents from the file. If you don’t want this behavior,
use two different instances of the class - one dedicated for loading from files and nothing else.</p>
<p>Here is a simple example which demonstrates how saving/loading from file works in the simplest case (i.e. no references to Ramses objects):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// Creates an empty LogicEngine instance, saves it to file and destroys the object</span>
<span class="linenos"> 2</span><span class="p">{</span>
<span class="linenos"> 3</span><span class="w">    </span><span class="n">ramses</span><span class="o">::</span><span class="n">LogicEngine</span><span class="w"> </span><span class="n">engine</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="n">engine</span><span class="p">.</span><span class="n">saveToFile</span><span class="p">(</span><span class="s">&quot;logicEngine.bin&quot;</span><span class="p">);</span>
<span class="linenos"> 5</span><span class="p">}</span>
<span class="linenos"> 6</span><span class="c1">// Loads the file we saved above into a freshly created LogicEngine instance</span>
<span class="linenos"> 7</span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">ramses</span><span class="o">::</span><span class="n">LogicEngine</span><span class="w"> </span><span class="n">engine</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">engine</span><span class="p">.</span><span class="n">loadFromFile</span><span class="p">(</span><span class="s">&quot;logicEngine.bin&quot;</span><span class="p">);</span>
<span class="linenos">10</span><span class="p">}</span>
</pre></div>
</div>
<p>After the call to <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine12loadFromFileENSt11string_viewEPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromFile()</span></code></a> successfully returns (refer to the <a class="reference internal" href="#error-handling"><span class="std std-ref">Error handling</span></a> section
for info on handling errors), the state of the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class will be overwritten with
the contents loaded from the file. This implies that all objects created prior loading will be deleted and pointers to them
will be pointing to invalid memory locations. We advise designing your object lifecycles around this and immediately dispose
such pointers after loading from file.</p>
</section>
<section id="file-compatibility">
<h2>File compatibility<a class="headerlink" href="#file-compatibility" title="Permalink to this heading"></a></h2>
<p>Starting with version <code class="docutils literal notranslate"><span class="pre">1.1.0</span></code>, the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> supports <code class="docutils literal notranslate"><span class="pre">feature</span> <span class="pre">levels</span></code> which ensure that
you can use a newer version of the library but keep your assets to the older version. This allows integrating
fixes and supporting multiple versions of the content toolchain at the same time. This mechanism is called
<code class="docutils literal notranslate"><span class="pre">feature</span> <span class="pre">toggle</span></code> in other projects and essentially enables trying out new features and rolling back if
they prove to be unstable and need more work.</p>
<p>How does it work? The Logic Engine provides an enum <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">rligic::EFeatureLevel</span></code> which represents the different
feature levels introduced since the last major version of the lib. For example, Ramses Logic 1.0 and 1.1 provide two
different feature levels each (<code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>). You can use <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code> selectively if you use version 1.1 of the library,
or you can use
only <code class="docutils literal notranslate"><span class="pre">1</span></code> if you use version 1.0. You can select at runtime which version to use by specifying a value
in the overloaded constructor of the class <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine11LogicEngineEN6ramses13EFeatureLevelE" title="ramses::LogicEngine::LogicEngine"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::LogicEngine()</span></code></a>. You can also check which version
is used in a binary file by using <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine23GetFeatureLevelFromFileENSt11string_viewERN6ramses13EFeatureLevelE" title="ramses::LogicEngine::GetFeatureLevelFromFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::GetFeatureLevelFromFile()</span></code></a>. Note that to load a file you must
always use the exact feature level that was used to export the file, otherwise the loading will fail.</p>
<p>For more details on the available feature levels and how to use them, see <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">ramses::EFeatureLevel</span></code>.</p>
</section>
<section id="file-compatibility-prior-version-1-1-and-feature-levels">
<h2>File compatibility (prior version 1.1 and feature levels)<a class="headerlink" href="#file-compatibility-prior-version-1-1-and-feature-levels" title="Permalink to this heading"></a></h2>
<p>Since version <code class="docutils literal notranslate"><span class="pre">0.7.0</span></code>, Ramses Logic binary files are backwards compatible.
This means that a newer version of the runtime can be used to load an older binary file, unless the file format version
had a breaking change and a newer version of the Logic Engine must be used.
The exact compatibility info is documented in the <a class="reference external" href="https://ramses-logic.readthedocs.io/en/latest/readme_ref.html#version-matrix">version matrix</a>.
There are some limitations:</p>
<ul class="simple">
<li><p>Loading a file older than v0.7.0 will result in an error with a runtime equal or newer than v0.7.0</p></li>
<li><p>Adding new features will still break the format and require re-export. We will explicitly list such breaking changes in the version matrix.</p></li>
</ul>
</section>
<section id="saving-and-loading-together-with-a-ramses-scene">
<h2>Saving and loading together with a Ramses scene<a class="headerlink" href="#saving-and-loading-together-with-a-ramses-scene" title="Permalink to this heading"></a></h2>
<p>In a slightly less simple, but more realistic setup, the Logic Engine will contain objects of type <code class="docutils literal notranslate"><span class="pre">Ramses&lt;Object&gt;Binding</span></code> which
contain references to Ramses objects. In that case, use the optional <code class="docutils literal notranslate"><span class="pre">ramses::Scene*</span></code> argument to <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine12loadFromFileENSt11string_viewEPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromFile()</span></code></a>
to specify the scene from which the references to Ramses objects should be resolved. <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> uses the <code class="docutils literal notranslate"><span class="pre">getSceneObjectId()</span></code> method of the
<code class="docutils literal notranslate"><span class="pre">ramses::SceneObject</span></code> class to track references to scene objects. This implies that those IDs must be the same after loading, otherwise
<a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine12loadFromFileENSt11string_viewEPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromFile()</span></code></a> will report error and fail. <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> makes no assumptions on the origin of the scene, its name
or ID.</p>
<p>For a full-fledged example, have a look at <a class="reference internal" href="examples/logic/05_serialization.html#save-load-from-file-example"><span class="std std-ref">the serialization example</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LogicEngine</span></code> expects that immediately after loading, the state of the <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene is the same as it was right before saving, and will not
modify <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> objects which are attached to bindings in the <code class="docutils literal notranslate"><span class="pre">LogicEngine</span></code> in its first update, unless they are linked to scripts or explicitly
overwritten by <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::Property::set()</span></code> calls after loading from the file. We strongly advice to always save and load
both the <code class="docutils literal notranslate"><span class="pre">Ramses</span></code> scene and the <code class="docutils literal notranslate"><span class="pre">LogicEngine</span></code> scene together to avoid data inconsistencies!</p>
</div>
</section>
<section id="using-memory-buffer-instead-of-file">
<h2>Using memory buffer instead of file<a class="headerlink" href="#using-memory-buffer-instead-of-file" title="Permalink to this heading"></a></h2>
<p>You can use <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine14loadFromBufferEPKv6size_tPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromBuffer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromBuffer()</span></code></a> to load the contents of the logic engine from your own memory. This can be useful
if you have your own file management logic, or the data comes from a different source than a file on disk. Be mindful that passing data buffers
over the boundaries of libraries can be unsafe with C++, and some errors/abuse can’t be reliably prevented. Make sure you check the size of
the buffer and don’t load from memory of untrusted origins.</p>
</section>
</section>
<section id="logging">
<h1>Logging<a class="headerlink" href="#logging" title="Permalink to this heading"></a></h1>
<p>Internally there are four log levels available.</p>
<ul class="simple">
<li><p>Info</p></li>
<li><p>Debug</p></li>
<li><p>Warn</p></li>
<li><p>Error</p></li>
</ul>
<p>By default all internal logging messages are sent to std::cout. You can toggle this with <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::Logger::SetDefaultLogging()</span></code>.
In addition, it is possible to have a custom log handler function which is called each time a log message is issued.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="n">Logger</span><span class="o">::</span><span class="n">SetLogHandler</span><span class="p">([](</span><span class="n">ElogMessageType</span><span class="w"> </span><span class="n">msgType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">message</span><span class="p">){</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">switch</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
<span class="linenos"> 5</span><span class="w">    </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">ELogMessageType</span><span class="o">::</span><span class="no">ERROR</span><span class="p">:</span>
<span class="linenos"> 7</span><span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Error: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="k">default</span><span class="o">:</span>
<span class="linenos">10</span><span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">11</span><span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="linenos">12</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">13</span><span class="p">});</span>
</pre></div>
</div>
<p>Inside the log handler function, you get the type of the message and the message itself as a std::string_view.
Keep in mind, that you can’t store the std::string_view. It will be invalid after the call to the log handler
function. If you need the message for later usage, store it in a std::string.</p>
<p>The amount of logging can be configured with <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::Logger::SetLogVerbosity()</span></code>. This affects both the default
logging and the custom logger.</p>
</section>
<section id="security-and-memory-safety">
<h1>Security and memory safety<a class="headerlink" href="#security-and-memory-safety" title="Permalink to this heading"></a></h1>
<p>One of the biggest challenges of modern <code class="docutils literal notranslate"><span class="pre">C++</span></code> is finding a balance between compatibility with older compilers
and platforms, while not sacrificing memory safety and code readibility. In the <code class="docutils literal notranslate"><span class="pre">RAMSES</span></code> ecosystem we try to
find a good balance by testing with different compilers, employing automation techniques and making use of
modern compiler-based tools to perform static code analysis and introspection. The methods and tools we use are:</p>
<ul class="simple">
<li><p>compiling on different compilers (MSVC, gcc, clang) with strict compiler settings</p></li>
<li><p>clang-tidy with fairly strict configuration</p></li>
<li><p>valgrind</p></li>
<li><p>treat warnings as errors</p></li>
<li><p>use various clang-based sanitizers (undefined behavior, thread sanitizer, address sanitizer)</p></li>
</ul>
<p>Those tools cover a lot of the standard sources of problems with <code class="docutils literal notranslate"><span class="pre">C++</span></code> revolving around memory. We also uphold
a strict code review, ensuring that each line of code is looked at by at least two pairs of eyes, for critical
parts of the code usually more than that. Still, no project is safe from bugs, thus we recommend following
some or all of the additional conventions and best practices from below subchapters to minimize the risk of
memory-related bugs and malicious attacks when using <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code>.</p>
<section id="additional-memory-safety-measures">
<h2>Additional memory safety measures<a class="headerlink" href="#additional-memory-safety-measures" title="Permalink to this heading"></a></h2>
<p>One of the biggest sources of bugs and security problems in <code class="docutils literal notranslate"><span class="pre">C++</span></code> arise from memory management, both in terms of
allocation/deallocation and memory access and boundary checks. <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> takes care of memory lifecycle
for all objects created by it, and provides raw pointer access to their memory. We suggest creating your own wrapper
objects for anything created or loaded by the <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngineE" title="ramses::LogicEngine"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngine</span></code></a> class and ensure it is destroyed exactly once
and only after not used any more.</p>
<p>Furthermore, pay special attention when passing strings as <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> to and from the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> as those
may not be terminated by a 0 and may lead to out of bounds accesses when used by functions expecting 0-termination.</p>
</section>
<section id="additional-security-considerations">
<h2>Additional security considerations<a class="headerlink" href="#additional-security-considerations" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Lua</span></code> is a script language, and as such provides great flexibility and expresiveness at the cost of
more error potential and security risks compared to other techniques for describing logic. The <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">engine</span></code> and the
underlying <code class="docutils literal notranslate"><span class="pre">sol</span></code> library do a lot of error checking and prevents undefined behavior by executing faulty script code,
but there are cases which can’t be checked.</p>
<p>To give one example, a script may overwrite the global variables <code class="docutils literal notranslate"><span class="pre">IN</span></code> or <code class="docutils literal notranslate"><span class="pre">OUT</span></code>
from within script code because of the nature of <code class="docutils literal notranslate"><span class="pre">Lua</span></code> scripts. This can’t be automatically checked by the runtime without
overloading the global <code class="docutils literal notranslate"><span class="pre">Lua</span></code> metatable and injecting every single assignment operation, which is too high a cost to avoid
faulty scripts.</p>
<p>To avoid malicious or broken script, we suggest implementing an additional security mechanism on top
of <code class="docutils literal notranslate"><span class="pre">Ramses</span> <span class="pre">Logic</span></code> which doesn’t allow execution of scripts of unknown origin. Also, build your code with errors in mind
and force scripts into an automated testing process. We also advise to use hashsums and whitelisting techniques to only
execute scripts which are tested and verified to be benign.</p>
</section>
<section id="sanitizing-of-files-and-buffers">
<h2>Sanitizing of files and buffers<a class="headerlink" href="#sanitizing-of-files-and-buffers" title="Permalink to this heading"></a></h2>
<p>Since the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> can deserialize itself from files and memory buffers, it opens possibilities for data corruption and
truncation. To mitigate those risks, we use Flatbuffer’s “Verify” feature which checks the integrity of data,
detects possible index-out-of-range issues and prevents binary data abuse. What it <em>doesn’t</em> check is
whether the actual memory buffer size (passed in <a class="reference internal" href="classes/logic.html#_CPPv4N6ramses11LogicEngine14loadFromBufferEPKv6size_tPN6ramses5SceneEb" title="ramses::LogicEngine::loadFromBuffer"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::LogicEngine::loadFromBuffer()</span></code></a>) is consistent with the size provided
by the user. The application must ensure that this size does not exceed the size of the actual memory!</p>
</section>
</section>
<section id="performance">
<h1>Performance<a class="headerlink" href="#performance" title="Permalink to this heading"></a></h1>
<section id="profiling-logic-update-cycles">
<h2>Profiling logic update cycles<a class="headerlink" href="#profiling-logic-update-cycles" title="Permalink to this heading"></a></h2>
<p>The SDK provides means to do basic measuring of logic network update times. See <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngineReport</span></code>
which gives several useful statistics, e.g. which nodes where executed and how long it took for each of them.
We suggest to collect this data over several update cycles in some worst case scenario (performance-wise)
and investigate which nodes take the most time to update. Also for normal use cases consider taking a look at
how many nodes were needed to be updated and if the topology could be improved so that this amount is reduced
to only the necessary nodes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An easy way to quickly get insight what happens inside a logic network is to use the <a class="reference internal" href="viewer.html#ramses-logic-viewer"><span class="std std-ref">GUI viewer</span></a>.
The viewer displays the stats reported by the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ramses::LogicEngineReport</span></code> dynamically or statically over multiple
update cycles.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Another easy way to quickly get insight what happens inside a logic network is to look at the <code class="docutils literal notranslate"><span class="pre">periodically</span> <span class="pre">logged</span> <span class="pre">node</span> <span class="pre">update</span> <span class="pre">statistics</span></code>
in the Ramses Shell. These are calculated over the last <code class="docutils literal notranslate"><span class="pre">N</span></code> updates which is adjustable.
Included are e.g. <code class="docutils literal notranslate"><span class="pre">update</span> <span class="pre">execution</span> <span class="pre">time</span> <span class="pre">in</span> <span class="pre">microseconds</span></code> or <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">of</span> <span class="pre">nodes</span> <span class="pre">executed</span> <span class="pre">in</span> <span class="pre">percentage</span> <span class="pre">of</span> <span class="pre">total</span></code> (both Average, Min and Max).</p>
</div>
</section>
<section id="optimizing-lua-code">
<h2>Optimizing Lua code<a class="headerlink" href="#optimizing-lua-code" title="Permalink to this heading"></a></h2>
<p>Lua is one of the fastest interpreted languages, especially when used efficiently. One of the best reading
we could recommend is the <a class="reference external" href="https://www.lua.org/gems/sample.pdf">second chapter</a> of the <code class="docutils literal notranslate"><span class="pre">Lua</span> <span class="pre">programming</span> <span class="pre">gems</span></code> by Roberto Ierusalimschy.
It’s short, and provides a very hands-on overview of what to do and what not to do when processing data with Lua.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code> extends plain lua with a way to interact with Ramses and with other scripts and modules. This is mostly
done by providing so-called <cite>userdata</cite> types and objects - those work like Lua tables, but have C++ implementation behind them.
Working with these generally costs more than working with plain Lua, since Lua knows how to optimize table accesses better than
usertypes. Try to minimize the access to <cite>userdata</cite> such as <code class="docutils literal notranslate"><span class="pre">IN</span></code>, <code class="docutils literal notranslate"><span class="pre">OUT</span></code> and modules as much as possible. The <a class="reference internal" href="#benchmarks"><span class="std std-ref">benchmarks</span></a>
provide more info on the difference between standard Lua and the Logic Engine dialect.</p>
</section>
<section id="benchmarks">
<h2>Benchmarks<a class="headerlink" href="#benchmarks" title="Permalink to this heading"></a></h2>
<p>In order to be able to track and improve
the runtime of the <code class="docutils literal notranslate"><span class="pre">Logic</span> <span class="pre">Engine</span></code>, we maintain a set of benchmarks based on the google-benchmark library.
These benchmarks can be used to measure the time it takes for specific operations under different loads.
We kindly ask our users and developers to report performance problems by creating a benchmark which describes
the specific use-case which needs optimizing. Refer to the
<a class="reference external" href="https://github.com/google/benchmark">google-benchmark docs</a> for hints how to
design good benchmarks, to set the time measurement units, derive O-complexity, etc.</p>
</section>
<section id="optimizing-file-size">
<h2>Optimizing file size<a class="headerlink" href="#optimizing-file-size" title="Permalink to this heading"></a></h2>
<p>It’s possible to reduce the file size of the exported LogicEngine data by storing the bytecode of the
Lua scripts and modules, instead of the source code. This might sound very attractive, but it has two
major caveats:</p>
<ul class="simple">
<li><p>Lua bytecode is notoriously vulnerable to malicious attacks</p></li>
<li><p>Bytecode is architecture-specific, i.e. you can’t run ARM bytecode on a x86 processor</p></li>
</ul>
<p>In order to provide a good mix between flexibility and performance, the LogicEngine allows choosing what
to be stored when saving into a binary file: only the source code, only the bytecode, or both. While the first
option is the safest and most robust, it is also the slowest. Storing both source and binary will offer both fast loading
when the architecture matches and a fallback solution when it doesn’t, but it results in larger binary files. Choose
an option which suits the needs of your application. Read more in <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ramses::SaveFileConfig::setLuaSavingMode()</span></code>.</p>
</section>
</section>
<section id="list-of-all-logic-examples">
<h1>List of all logic examples<a class="headerlink" href="#list-of-all-logic-examples" title="Permalink to this heading"></a></h1>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/00_minimal.html">Minimal logic example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/01a_primitive_properties.html">Example with primitive properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/01b_struct_properties.html">Example with structured properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/01c_array_properties.html">Example with indexed (vector, array) properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/02_errors_compile_time.html">Handling compilation errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/03_errors_runtime.html">Handling runtime errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/04_ramses_scene.html">Example with Ramses</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/05_serialization.html">Save/load from file example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/07_links.html">Links example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/08a_static_animation.html">Animation example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/08b_dynamic_animation.html">Dynamic animation (animateTo) example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/09_modules.html">Modules example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/10_globals.html">Globals example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/11_interfaces.html">Interfaces example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/12_anchor_point.html">Anchor points example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/13_render_order.html">Render order example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/14_skinbinding.html">SkinBinding example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/logic/15_meshnodebinding.html">MeshNodeBinding example</a></li>
</ul>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="examples/core/00_minimal.html" class="btn btn-neutral float-left" title="Minimal example" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples/logic/00_minimal.html" class="btn btn-neutral float-right" title="Minimal logic example" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, BMW AG.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>